// Generated by delombok at Fri Jul 19 01:02:22 PDT 2024
/*
 * Copyright 2019 Maksim Zheravin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package exchange.core2.core.common.api.reports;

import exchange.core2.core.common.Order;
import exchange.core2.core.common.PositionDirection;
import exchange.core2.core.common.UserStatus;
import exchange.core2.core.utils.SerializationUtils;
import lombok.*;
import net.openhft.chronicle.bytes.BytesIn;
import net.openhft.chronicle.bytes.BytesOut;
import net.openhft.chronicle.bytes.WriteBytesMarshallable;
import org.eclipse.collections.impl.map.mutable.primitive.IntLongHashMap;
import org.eclipse.collections.impl.map.mutable.primitive.IntObjectHashMap;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class SingleUserReportResult implements ReportResult {
    @java.lang.SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(SingleUserReportResult.class);
    public static SingleUserReportResult IDENTITY = new SingleUserReportResult(0L, null, null, null, null, QueryExecutionStatus.OK);
    private final long uid;
    // risk engine: user profile from
    //private final UserProfile userProfile;
    private final UserStatus userStatus;
    private final IntLongHashMap accounts;
    private final IntObjectHashMap<Position> positions;
    // matching engine: orders placed by user
    // symbol -> orders
    private final IntObjectHashMap<List<Order>> orders;
    // status
    private final QueryExecutionStatus queryExecutionStatus;

    public static SingleUserReportResult createFromMatchingEngine(long uid, IntObjectHashMap<List<Order>> orders) {
        return new SingleUserReportResult(uid, null, null, null, orders, QueryExecutionStatus.OK);
    }

    public static SingleUserReportResult createFromRiskEngineFound(long uid, UserStatus userStatus, IntLongHashMap accounts, IntObjectHashMap<Position> positions) {
        return new SingleUserReportResult(uid, userStatus, accounts, positions, null, QueryExecutionStatus.OK);
    }

    public static SingleUserReportResult createFromRiskEngineNotFound(long uid) {
        return new SingleUserReportResult(uid, null, null, null, null, QueryExecutionStatus.USER_NOT_FOUND);
    }

    public Map<Long, Order> fetchIndexedOrders() {
        return orders.stream().flatMap(Collection::stream).collect(Collectors.toMap(Order::getOrderId, ord -> ord));
    }

    private SingleUserReportResult(final BytesIn bytesIn) {
        this.uid = bytesIn.readLong();
//        this.userProfile = bytesIn.readBoolean() ? new UserProfile(bytesIn) : null;
        this.userStatus = bytesIn.readBoolean() ? UserStatus.of(bytesIn.readByte()) : null;
        this.accounts = bytesIn.readBoolean() ? SerializationUtils.readIntLongHashMap(bytesIn) : null;
        this.positions = bytesIn.readBoolean() ? SerializationUtils.readIntHashMap(bytesIn, Position::new) : null;
        this.orders = bytesIn.readBoolean() ? SerializationUtils.readIntHashMap(bytesIn, b -> SerializationUtils.readList(b, Order::new)) : null;
        this.queryExecutionStatus = QueryExecutionStatus.of(bytesIn.readInt());
    }

    @Override
    public void writeMarshallable(final BytesOut bytes) {
        bytes.writeLong(uid);
//        bytes.writeBoolean(userProfile != null);
//        if (userProfile != null) {
//            userProfile.writeMarshallable(bytes);
//        }
        bytes.writeBoolean(userStatus != null);
        if (userStatus != null) {
            bytes.writeByte(userStatus.getCode());
        }
        bytes.writeBoolean(accounts != null);
        if (accounts != null) {
            SerializationUtils.marshallIntLongHashMap(accounts, bytes);
        }
        bytes.writeBoolean(positions != null);
        if (positions != null) {
            SerializationUtils.marshallIntHashMap(positions, bytes);
        }
        bytes.writeBoolean(orders != null);
        if (orders != null) {
            SerializationUtils.marshallIntHashMap(orders, bytes, symbolOrders -> SerializationUtils.marshallList(symbolOrders, bytes));
        }
        bytes.writeInt(queryExecutionStatus.code);
    }


    public enum QueryExecutionStatus {
        OK(0), USER_NOT_FOUND(1);
        private final int code;

        QueryExecutionStatus(int code) {
            this.code = code;
        }

        public static QueryExecutionStatus of(int code) {
            switch (code) {
            case 0: 
                return OK;
            case 1: 
                return USER_NOT_FOUND;
            default: 
                throw new IllegalArgumentException("unknown ExecutionStatus:" + code);
            }
        }
    }

    public static SingleUserReportResult merge(final Stream<BytesIn> pieces) {
        return pieces.map(SingleUserReportResult::new).reduce(IDENTITY, (a, b) -> new SingleUserReportResult(a.uid, 
//                                SerializationUtils.preferNotNull(a.userProfile, b.userProfile),
        SerializationUtils.preferNotNull(a.userStatus, b.userStatus), SerializationUtils.preferNotNull(a.accounts, b.accounts), SerializationUtils.preferNotNull(a.positions, b.positions), SerializationUtils.mergeOverride(a.orders, b.orders), a.queryExecutionStatus != QueryExecutionStatus.OK ? a.queryExecutionStatus : b.queryExecutionStatus));
    }


    public static class Position implements WriteBytesMarshallable {
        public final int quoteCurrency;
        // open positions state (for margin trades only)
        public final PositionDirection direction;
        public final long openVolume;
        public final long openPriceSum;
        public final long profit;
        // pending orders total size
        public final long pendingSellSize;
        public final long pendingBuySize;

        private Position(BytesIn bytes) {
            this.quoteCurrency = bytes.readInt();
            this.direction = PositionDirection.of(bytes.readByte());
            this.openVolume = bytes.readLong();
            this.openPriceSum = bytes.readLong();
            this.profit = bytes.readLong();
            this.pendingSellSize = bytes.readLong();
            this.pendingBuySize = bytes.readLong();
        }

        @Override
        public void writeMarshallable(BytesOut bytes) {
            bytes.writeInt(quoteCurrency);
            bytes.writeByte((byte) direction.getMultiplier());
            bytes.writeLong(openVolume);
            bytes.writeLong(openPriceSum);
            bytes.writeLong(profit);
            bytes.writeLong(pendingSellSize);
            bytes.writeLong(pendingBuySize);
        }

        @java.lang.SuppressWarnings("all")
        public Position(final int quoteCurrency, final PositionDirection direction, final long openVolume, final long openPriceSum, final long profit, final long pendingSellSize, final long pendingBuySize) {
            this.quoteCurrency = quoteCurrency;
            this.direction = direction;
            this.openVolume = openVolume;
            this.openPriceSum = openPriceSum;
            this.profit = profit;
            this.pendingSellSize = pendingSellSize;
            this.pendingBuySize = pendingBuySize;
        }

        @java.lang.SuppressWarnings("all")
        public int getQuoteCurrency() {
            return this.quoteCurrency;
        }

        @java.lang.SuppressWarnings("all")
        public PositionDirection getDirection() {
            return this.direction;
        }

        @java.lang.SuppressWarnings("all")
        public long getOpenVolume() {
            return this.openVolume;
        }

        @java.lang.SuppressWarnings("all")
        public long getOpenPriceSum() {
            return this.openPriceSum;
        }

        @java.lang.SuppressWarnings("all")
        public long getProfit() {
            return this.profit;
        }

        @java.lang.SuppressWarnings("all")
        public long getPendingSellSize() {
            return this.pendingSellSize;
        }

        @java.lang.SuppressWarnings("all")
        public long getPendingBuySize() {
            return this.pendingBuySize;
        }
    }

    @Override
    public String toString() {
        return "SingleUserReportResult{userProfile=" + userStatus + ", accounts=" + accounts + ", orders=" + orders + ", queryExecutionStatus=" + queryExecutionStatus + '}';
    }

    @java.lang.SuppressWarnings("all")
    private SingleUserReportResult(final long uid, final UserStatus userStatus, final IntLongHashMap accounts, final IntObjectHashMap<Position> positions, final IntObjectHashMap<List<Order>> orders, final QueryExecutionStatus queryExecutionStatus) {
        this.uid = uid;
        this.userStatus = userStatus;
        this.accounts = accounts;
        this.positions = positions;
        this.orders = orders;
        this.queryExecutionStatus = queryExecutionStatus;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public boolean equals(final java.lang.Object o) {
        if (o == this) return true;
        if (!(o instanceof SingleUserReportResult)) return false;
        final SingleUserReportResult other = (SingleUserReportResult) o;
        if (this.getUid() != other.getUid()) return false;
        final java.lang.Object this$userStatus = this.getUserStatus();
        final java.lang.Object other$userStatus = other.getUserStatus();
        if (this$userStatus == null ? other$userStatus != null : !this$userStatus.equals(other$userStatus)) return false;
        final java.lang.Object this$accounts = this.getAccounts();
        final java.lang.Object other$accounts = other.getAccounts();
        if (this$accounts == null ? other$accounts != null : !this$accounts.equals(other$accounts)) return false;
        final java.lang.Object this$positions = this.getPositions();
        final java.lang.Object other$positions = other.getPositions();
        if (this$positions == null ? other$positions != null : !this$positions.equals(other$positions)) return false;
        final java.lang.Object this$orders = this.getOrders();
        final java.lang.Object other$orders = other.getOrders();
        if (this$orders == null ? other$orders != null : !this$orders.equals(other$orders)) return false;
        final java.lang.Object this$queryExecutionStatus = this.getQueryExecutionStatus();
        final java.lang.Object other$queryExecutionStatus = other.getQueryExecutionStatus();
        if (this$queryExecutionStatus == null ? other$queryExecutionStatus != null : !this$queryExecutionStatus.equals(other$queryExecutionStatus)) return false;
        return true;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final long $uid = this.getUid();
        result = result * PRIME + (int) ($uid >>> 32 ^ $uid);
        final java.lang.Object $userStatus = this.getUserStatus();
        result = result * PRIME + ($userStatus == null ? 43 : $userStatus.hashCode());
        final java.lang.Object $accounts = this.getAccounts();
        result = result * PRIME + ($accounts == null ? 43 : $accounts.hashCode());
        final java.lang.Object $positions = this.getPositions();
        result = result * PRIME + ($positions == null ? 43 : $positions.hashCode());
        final java.lang.Object $orders = this.getOrders();
        result = result * PRIME + ($orders == null ? 43 : $orders.hashCode());
        final java.lang.Object $queryExecutionStatus = this.getQueryExecutionStatus();
        result = result * PRIME + ($queryExecutionStatus == null ? 43 : $queryExecutionStatus.hashCode());
        return result;
    }

    @java.lang.SuppressWarnings("all")
    public long getUid() {
        return this.uid;
    }

    @java.lang.SuppressWarnings("all")
    public UserStatus getUserStatus() {
        return this.userStatus;
    }

    @java.lang.SuppressWarnings("all")
    public IntLongHashMap getAccounts() {
        return this.accounts;
    }

    @java.lang.SuppressWarnings("all")
    public IntObjectHashMap<Position> getPositions() {
        return this.positions;
    }

    @java.lang.SuppressWarnings("all")
    public IntObjectHashMap<List<Order>> getOrders() {
        return this.orders;
    }

    @java.lang.SuppressWarnings("all")
    public QueryExecutionStatus getQueryExecutionStatus() {
        return this.queryExecutionStatus;
    }
}
